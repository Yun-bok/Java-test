package 정리;

public class Summary5 {

	public static void main(String[] args) {
		Pet3 pet; // = new Pet3(); 객체 생성 불가
		//pet = new Dog3();
		pet.Eat();
		pet.Sound();
		//pet.Bite(); Dog3 -> Pet3 -> Dog3
		//if(pet instanceof Dog3) {
			//Dog3 dog = (Dog3)pet;
			//dog.Bite();
			//dog.Eat();
			//dog.Sound();
		}
		//클래스 - 어떤 기준으로 공통된 정보(필드,메서드)를 묶어놓은것
		//외부에 어떤것이 있는지는 보여주지만 안에 구현은 보여주지않아요

		//객체지향 프로그래밍 특징
		//상속,캡슐화,다형성
		//상속 (부모-> 자식), (자식이 부모한테 포함관계)
		//부모의 멤버(필드,메서드) -> 자식이 받아서 사용 ->private
		
		//super -> 부모의 객체 접근
		//->super.print()-메서드   super() - 생성자
		//부모의 메서드를 재정의 -> 오버라이딩
		// -> 부모의 메서드와 구조(반환타입, 매개변수타입,개수가 일치)
		//@Override -> 오버라이딩이 잘됬는지 컴파일러가 확인
		
		//캡슐화 - 알약
		//공통된 정보들을 묶어놓는것 , 외부에 구현내용(ex - 메서드 구현내용 공개 X
		
		//다형성 - 많은 형태를 가지는 성질(한자)
		//동일한 타입을 사용하지만 다양한 결과
		//부모타입에 모든 자식의 객체 대입(저장)가능
		
		//클래스 타입변환
		//자동 타입 변환
		//부모클래스 변수이름 = 자식클래스 객체(new 자식());
		//자식 -> 부모(부모의 부모)
		//부모의 타입으로 변하면 객체는 부모에 선언된 필드와 메서드만 사용가능
		//오버라이딩 된 메서드는 자식의 메서드 호출
		
		//강제 타입변환
		//부모 -> 자식
		//조건 : 자식 -> 부모 -> 자식
		//자식타입에서 부모타입으로 자동변환 후 다시 자식으로 변환할때
		//강제 타입변환 필요할때
		//자식 타입에 선언된 필드와 메서드를 호출해야 하는 경우
		
		//추상클래스
		//공통된 특성을 추출
		//공통되는 필드와 메서드를 정의한 클래스
		//***객체를 만들어서 사용하지 않을 클래스
		//강아지,고양이 -> 애완동물(부모클래스,추상클래스)
		//설계자(개발자)마다 클래스의 필드와 메서드가 이름 다르다 -> 통일
		//***생성 불가
		//Pet pet = new Pet(); -> 불가능
		//Pet pet = new Cat(); -> 가능
		//*** 추상 메서드 사용가능
		//선언부만 작성 -> public void print(String mes); {} 작성 X
		//강제성 -> 자식클래스에서 무조건 오버라이딩해야한다.
		//추상클래스, 추상메서드 -> abstract
	}
	
	abstract class Pet3{
		//추상메서드
		abstract void Sound();
		//메서드
		void Eat() {
			
		}
	}


